---
title: Python Overview
description: Overview of Python
---

- Python is a high-level, interpreted programming language that is easy to learn and use.
- Python is a popular language for web development, data analysis, artificial intelligence, and scientific computing.
- Python is an interpreted language, which means that it runs on an interpreter and does not need to be compiled before it can be executed.
- Python is a dynamically typed language, which means that the type of a variable is determined at runtime rather than at compile time.

### Python Syntax

- Python uses indentation to define the scope of loops, functions, and other blocks of code.
- Python does not use curly braces to define the scope of code blocks, but rather uses indentation.

```python
if x > 0:
    print("x is positive")
else:
    print("x is negative")
```

## Immutable vs Mutable

- Python has two types of data types: mutable and immutable.
- Mutable objects can be changed after they are created, while immutable objects cannot be changed after they are created.

### Immutable

- Strings
- Tuples
- Numbers
- Frozen Sets

```python
# Immutable
string = "Hello, World!"
string[0] = "H"  # This will raise an error

```

``` text
                    Python Memory Model
            ═══════════════════════════════════

Stack (References)          Heap (Objects)
┌──────────────────┐       ╔════════════════════╗
│                  │       ║    String Object   ║
│ str1 ────────────┼─────→║     "Hello"         ║
│                  │       ║    (id: 1234)      ║
│                  │       ║                    ║
│ str2 ────────────┼─┐     ╚════════════════════╝
│                  │ │     
│                  │ │     ╔════════════════════╗
│ tuple1 ──────────┼─┼────→║    Tuple Object    ║
│                  │ │     ║    (1, 2, 3)       ║
│                  │ │     ║    (id: 5678)      ║
│                  │ │     ╚════════════════════╝
│                  │ │     
│                  │ │     ╔═══════════════════╗
│                  │ └────→║    String Object   ║
│                  │       ║    "Hello"         ║
│                  │       ║    (id: 9012)      ║
└──────────────────┘       ╚════════════════════╝

╔════════════════════════════════════════════════════╗
║            Memory Model Characteristics            ║
╠════════════════════════════════════════════════════╣
║ • Objects stored in heap memory                    ║
║ • References stored in stack memory                ║
║ • Multiple references can point to same object     ║
║ • Memory managed by Python's garbage collector     ║
╚════════════════════════════════════════════════════╝
```

### Mutable

- Lists
- Dictionaries
- Sets

```python
# Mutable
list = [1, 2, 3]
list[0] = 0  # This will not raise an error
```

## Data Types/Object Types

Python has several built-in data types, including integers, floats, strings, lists, tuples, dictionaries, and sets.

- Numbers : `1234`, `12.34`, `12+34j`
- Strings : `"Hello, World!"`
- Lists : `[1, 2, 3]`, `["apple", "banana", "cherry"]`
- Tuples : `(1, 2, 3)`, `("apple", "banana", "cherry")`
- Dictionaries : `{"name": "John", "age": 30}`, `{"apple": 1, "banana": 2, "cherry": 3}`
- Sets : `{1, 2, 3}`, `{"apple", "banana", "cherry"}`
- File : `open("file.txt", "r")`
- Function : `def my_function():`
- Class : `class MyClass:`
- Boolean : `True`, `False`
- None : `None`
- Module : `import math`

#### Advanced Types

- Decorators : `@decorator`
- Generators : `def my_generator():`
- Iterators : `iter(my_list)`
- Context Managers : `with open("file.txt", "r") as file:`

### Numbers

Python supports three numeric types: integers (whole numbers), floating-point numbers (decimals), and complex numbers.

```python
# Number Types
integer = 42          # int: whole numbers
float_num = 3.14      # float: decimal numbers
complex_num = 2 + 3j  # complex: real + imaginary

# Integer Operations
x, y = 10, 3

# Basic Arithmetic
sum = x + y           # 13
diff = x - y          # 7
product = x * y       # 30
quotient = x / y      # 3.3333... (float division)
floor_div = x // y    # 3 (integer division)
remainder = x % y     # 1 (modulus)
power = x ** y        # 1000 (exponentiation)

# Integer Methods
abs(-25)              # 25
pow(2, 3)             # 8 (same as 2 ** 3)
divmod(10, 3)         # (3, 1) (quotient and remainder)

# Number System Conversions
bin(10)               # '0b1010' (binary)
oct(10)               # '0o12' (octal)
hex(10)               # '0xa' (hexadecimal)
int('1010', 2)        # 10 (binary to decimal)
int('12', 8)          # 10 (octal to decimal)
int('a', 16)          # 10 (hex to decimal)

# Float Operations
pi = 3.14159
e = 2.71828

# Float Methods
round(3.14159, 2)     # 3.14
round(3.5)            # 4
float.is_integer(3.0)  # True
float.as_integer_ratio(0.125)  # (1, 8)

# Math Module Functions
import math

# Constants
math.pi               # 3.141592653589793
math.e                # 2.718281828459045
math.inf              # Infinity
math.nan              # Not a Number

# Basic Math Functions
math.ceil(3.7)        # 4 (round up)
math.floor(3.7)       # 3 (round down)
math.trunc(3.7)       # 3 (truncate decimal)
math.fabs(-3.7)       # 3.7 (absolute value)

# Power and Logarithmic Functions
math.sqrt(16)         # 4.0
math.pow(2, 3)        # 8.0
math.log(100, 10)     # 2.0 (log base 10)
math.log2(8)          # 3.0 (log base 2)
math.exp(2)           # 7.389... (e^2)

# Trigonometric Functions
math.sin(math.pi/2)   # 1.0
math.cos(math.pi)     # -1.0
math.tan(math.pi/4)   # 1.0
math.degrees(math.pi)  # 180.0
math.radians(180)     # 3.141592653589793

# Statistical Functions
math.factorial(5)     # 120
math.gcd(12, 8)       # 4 (greatest common divisor)
math.lcm(4, 6)        # 12 (least common multiple)

# Complex Numbers
z = 3 + 4j
z.real               # 3.0 (real part)
z.imag               # 4.0 (imaginary part)
abs(z)               # 5.0 (magnitude)
z.conjugate()        # (3-4j)

# Number Properties
isinstance(42, int)    # True
isinstance(3.14, float)# True
float('inf')          # Infinity
float('-inf')         # -Infinity
float('nan')          # NaN

# Decimal Module (for precise decimal arithmetic)
from decimal import Decimal, getcontext
getcontext().prec = 4  # Set precision
Decimal('0.1') + Decimal('0.2')  # Decimal('0.3000')

# Random Module
import random
random.randint(1, 10)  # Random integer between 1 and 10
random.random()        # Random float between 0 and 1
random.uniform(1, 10)  # Random float between 1 and 10
```

### Strings

Strings in Python are immutable sequences of characters.

```python
# String Creation
single = 'Hello'
double = "Hello"
multi_line = '''Multiple
line string'''
raw = r'Raw\nstring'    # Treats backslashes as literal

# Basic Operations
s1 = "Hello"
s2 = "World"
concat = s1 + " " + s2  # "Hello World"
repeat = s1 * 3         # "HelloHelloHello"
length = len(s1)        # 5

# String Indexing and Slicing
text = "Python"
first = text[0]         # 'P'
last = text[-1]         # 'n'
slice = text[1:4]       # 'yth'
reverse = text[::-1]    # 'nohtyP'

# Common String Methods
text = "  Python Programming  "
text.upper()           # "  PYTHON PROGRAMMING  "
text.lower()           # "  python programming  "
text.strip()           # "Python Programming"
text.replace('P', 'J') # "  Jython Jrogramming  "
text.split()           # ["Python", "Programming"]

# String Checks
text = "Python3"
text.isalpha()         # False
text.isalnum()         # True
text.isdigit()         # False
text.startswith('Py')  # True
text.endswith('3')     # True

# String Formatting
name = "Alice"
age = 25

# f-strings (Python 3.6+)
f"Name: {name}, Age: {age}"

# format() method
"Name: {}, Age: {}".format(name, age)
"Name: {n}, Age: {a}".format(n=name, a=age)

# % operator (older style)
"Name: %s, Age: %d" % (name, age)

# String Join and Split
words = ['Python', 'is', 'awesome']
" ".join(words)        # "Python is awesome"
"Python-is-cool".split('-')  # ['Python', 'is', 'cool']

# String Search
text = "Python Programming"
text.find('Pro')       # 7 (returns index)
text.count('P')        # 2 (count occurrences)
'Pro' in text          # True

# Advanced String Methods
text = "python programming"
text.capitalize()      # "Python programming"
text.title()          # "Python Programming"
text.swapcase()       # "PYTHON PROGRAMMING"
text.center(20, '*')   # "**python programming**"
text.ljust(20, '-')    # "python programming---"
text.rjust(20, '-')    # "---python programming"

# String Encoding/Decoding
text = "Hello"
encoded = text.encode('utf-8')  # b'Hello'
decoded = encoded.decode('utf-8')  # 'Hello'

# Escape Characters
"""
\n - newline
\t - tab
\\ - backslash
\' - single quote
\" - double quote
\r - carriage return
\b - backspace
"""
```

### Lists

Lists in Python are mutable sequences that can hold mixed data types.

```python
# List Creation
empty_list = []
numbers = [1, 2, 3, 4, 5]
mixed = [1, "hello", 3.14, True]
nested = [1, [2, 3], [4, 5, 6]]
list_comp = [x for x in range(5)]  # [0, 1, 2, 3, 4]

# Basic Operations
lst = [1, 2, 3]
length = len(lst)           # 3
concatenate = lst + [4, 5]  # [1, 2, 3, 4, 5]
repeat = lst * 2            # [1, 2, 3, 1, 2, 3]

# Indexing and Slicing
numbers = [0, 1, 2, 3, 4, 5]
first = numbers[0]          # 0
last = numbers[-1]          # 5
subset = numbers[1:4]       # [1, 2, 3]
step = numbers[::2]         # [0, 2, 4]
reverse = numbers[::-1]     # [5, 4, 3, 2, 1, 0]

# List Methods
lst = [1, 2, 3]
lst.append(4)              # [1, 2, 3, 4]
lst.extend([5, 6])        # [1, 2, 3, 4, 5, 6]
lst.insert(1, 10)         # [1, 10, 2, 3, 4, 5, 6]
lst.remove(10)            # [1, 2, 3, 4, 5, 6]
popped = lst.pop()        # 6, lst is now [1, 2, 3, 4, 5]
popped_index = lst.pop(1) # 2, lst is now [1, 3, 4, 5]

# List Methods - Part 2
numbers = [3, 1, 4, 1, 5, 9, 2, 6]
numbers.sort()            # [1, 1, 2, 3, 4, 5, 6, 9]
numbers.reverse()         # [9, 6, 5, 4, 3, 2, 1, 1]
count = numbers.count(1)  # 2
index = numbers.index(5)  # 2
numbers.clear()           # []

# List Comprehensions
squares = [x**2 for x in range(5)]              # [0, 1, 4, 9, 16]
evens = [x for x in range(10) if x % 2 == 0]    # [0, 2, 4, 6, 8]
matrix = [[i+j for j in range(3)] for i in range(3)]
# [[0, 1, 2],
#  [1, 2, 3],
#  [2, 3, 4]]

# Common Operations
nums = [1, 2, 3, 4, 5]
min_val = min(nums)       # 1
max_val = max(nums)       # 5
sum_val = sum(nums)       # 15
sorted_nums = sorted(nums, reverse=True)  # [5, 4, 3, 2, 1]

# List Copying
original = [1, [2, 3], 4]
shallow = original.copy()              # or original[:]
import copy
deep = copy.deepcopy(original)         # Deep copy

# List as Stack and Queue
stack = [1, 2, 3]
stack.append(4)           # push: [1, 2, 3, 4]
stack.pop()               # pop: 4, stack: [1, 2, 3]

from collections import deque
queue = deque([1, 2, 3])
queue.append(4)           # [1, 2, 3, 4]
queue.popleft()           # 1, queue: [2, 3, 4]

# List Membership and Iteration
numbers = [1, 2, 3, 4, 5]
3 in numbers             # True
for num in numbers:
    print(num)           # Prints each number

# List with enumerate
for i, num in enumerate(numbers):
    print(f"Index {i}: {num}")

# List Unpacking
first, *rest, last = [1, 2, 3, 4, 5]
# first = 1, rest = [2, 3, 4], last = 5

# Advanced Operations
# Filter
odds = list(filter(lambda x: x % 2, numbers))  # [1, 3, 5]

# Map
doubles = list(map(lambda x: x * 2, numbers))  # [2, 4, 6, 8, 10]

# Zip
names = ['Alice', 'Bob']
ages = [25, 30]
list(zip(names, ages))   # [('Alice', 25), ('Bob', 30)]

```

### Tuples

### Tuples

Tuples are immutable sequences in Python, making them ideal for data that shouldn't change.

```python
# Tuple Creation
empty = ()
single = (1,)             # Note the comma
multiple = (1, 2, 3)
mixed = (1, "hello", 3.14)
nested = (1, (2, 3), [4, 5])

# Basic Operations
tup = (1, 2, 3)
length = len(tup)         # 3
concat = tup + (4, 5)     # (1, 2, 3, 4, 5)
repeat = tup * 2          # (1, 2, 3, 1, 2, 3)

# Indexing and Slicing
numbers = (0, 1, 2, 3, 4)
first = numbers[0]        # 0
last = numbers[-1]        # 4
subset = numbers[1:4]     # (1, 2, 3)
reverse = numbers[::-1]   # (4, 3, 2, 1, 0)

# Tuple Methods
tup = (1, 2, 2, 3, 2)
count = tup.count(2)      # 3 (counts occurrences)
index = tup.index(2)      # 1 (first occurrence)

# Tuple Unpacking
x, y, z = (1, 2, 3)       # x=1, y=2, z=3
first, *rest = (1, 2, 3, 4)  # first=1, rest=[2, 3, 4]

# Named Tuples
from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])
p = Point(11, 22)
print(p.x, p.y)          # 11 22

# Tuple vs List Performance
"""
Advantages:
1. Immutable (safer)
2. Slightly smaller memory
3. Can be used as dictionary keys
4. Slightly faster than lists
"""

# Common Use Cases
# 1. Returning multiple values
def get_coords():
    return (3, 4)

# 2. Dictionary keys
locations = {(0, 0): 'origin', (1, 1): 'point'}

# 3. Data integrity
constants = (3.14, 2.718, 1.414)

# Tuple Comparison
t1 = (1, 2, 3)
t2 = (1, 2, 4)
t1 < t2                  # True (compares elements)

# Conversion
list_to_tuple = tuple([1, 2, 3])
string_to_tuple = tuple("hello")  # ('h','e','l','l','o')


# Advanced Operations
# Zip with tuples
x = (1, 2, 3)
y = ('a', 'b', 'c')
list(zip(x, y))          # [(1,'a'), (2,'b'), (3,'c')]

# Filter and Map
filtered = tuple(x for x in (1,2,3,4) if x % 2 == 0)  # (2, 4)
mapped = tuple(map(lambda x: x*2, (1,2,3)))  # (2, 4, 6)

# Nested Tuple Operations
nested = ((1, 2), (3, 4))
flattened = tuple(y for x in nested for y in x)  # (1, 2, 3, 4)

# Type Checking
isinstance((1, 2), tuple)  # True
type((1, 2)).__name__     # 'tuple'
```

### Dictionaries

### Dictionaries

Dictionaries are mutable, unordered collections of key-value pairs.

```python
# Dictionary Creation
empty = {}
simple = {'name': 'John', 'age': 30}
dict_constructor = dict(name='John', age=30)
from_pairs = dict([('name', 'John'), ('age', 30)])
dict_comp = {x: x**2 for x in range(5)}  # {0:0, 1:1, 2:4, 3:9, 4:16}

# Basic Operations
d = {'a': 1, 'b': 2}
length = len(d)           # 2
value = d['a']           # 1
d['c'] = 3               # Add new key-value pair
del d['b']               # Delete key-value pair

# Dictionary Methods
# Getting Values
d = {'a': 1, 'b': 2, 'c': 3}
value = d.get('a')       # 1
value = d.get('z', 0)    # 0 (default value if key not found)

# Modifying Dictionaries
d1 = {'a': 1, 'b': 2}
d2 = {'b': 3, 'c': 4}
d1.update(d2)            # d1 = {'a': 1, 'b': 3, 'c': 4}

# Keys, Values, and Items
keys = d.keys()          # dict_keys(['a', 'b', 'c'])
values = d.values()      # dict_values([1, 2, 3])
items = d.items()        # dict_items([('a',1), ('b',2), ('c',3)])

# Common Methods
d = {'a': 1, 'b': 2}
popped = d.pop('a')      # 1, d = {'b': 2}
item = d.popitem()       # ('b', 2), d = {}
d.clear()                # {}

# Dictionary Comprehension
squares = {x: x**2 for x in range(5)}
filtered = {k: v for k, v in d.items() if v > 0}

# Merging Dictionaries
# Python 3.5+
d1 = {'a': 1}
d2 = {'b': 2}
merged = {**d1, **d2}    # {'a': 1, 'b': 2}

# Python 3.9+
merged = d1 | d2         # {'a': 1, 'b': 2}

# Nested Dictionaries
nested = {
    'user1': {'name': 'John', 'age': 30},
    'user2': {'name': 'Jane', 'age': 25}
}
value = nested['user1']['name']  # 'John'

# Dictionary Views
d = {'a': 1, 'b': 2}
keys = d.keys()          # Dynamic view of keys
d['c'] = 3               # keys now includes 'c'

# Safe Dictionary Access
# Using get()
value = d.get('z', 'not found')  # Default if key missing

# Using setdefault()
d = {'a': 1}
value = d.setdefault('b', 0)  # Adds 'b': 0 if 'b' missing

# Dictionary Membership
'a' in d                 # True (key check)
1 in d.values()          # True (value check)

# Dictionary Iteration
d = {'a': 1, 'b': 2, 'c': 3}

# Iterate over keys (default)
for key in d:
    print(key)

# Iterate over key-value pairs
for key, value in d.items():
    print(f"{key}: {value}")

# Iterate over values
for value in d.values():
    print(value)

# Dictionary Copying
# Shallow copy
d1 = {'a': [1, 2]}
d2 = d1.copy()

# Deep copy
import copy
d3 = copy.deepcopy(d1)

# Advanced Operations
# Dictionary to JSON
import json
json_str = json.dumps(d)  # Convert to JSON string
d = json.loads(json_str)  # Parse JSON string

# DefaultDict
from collections import defaultdict
d = defaultdict(list)     # Default value is empty list
d['new_key'].append(1)    # No KeyError if key missing

# OrderedDict (Python 3.7+ dicts are ordered by default)
from collections import OrderedDict
od = OrderedDict([('a', 1), ('b', 2)])

# Counter
from collections import Counter
c = Counter(['a', 'b', 'a'])  # {'a': 2, 'b': 1}

# Type Checking
isinstance({}, dict)      # True
type({}).__name__        # 'dict'
```

### File Handling

Python provides built-in functions and methods for file operations.

```python
# Basic File Operations
# Opening Files
file = open('example.txt', 'r')  # Read mode
file = open('example.txt', 'w')  # Write mode
file = open('example.txt', 'a')  # Append mode

# File Modes
"""
'r'  - Read (default)
'w'  - Write (truncates file)
'a'  - Append
'x'  - Exclusive creation
'b'  - Binary mode
't'  - Text mode (default)
'+'  - Read and write
"""

# Using with Statement (Recommended)
with open('example.txt', 'r') as file:
    content = file.read()
# File automatically closes after with block

# Reading Files
# Read entire file
with open('example.txt', 'r') as file:
    content = file.read()         # Read all as string
    content = file.read(5)        # Read 5 characters
    lines = file.readlines()      # Read all lines into list
    line = file.readline()        # Read one line

# Reading line by line (memory efficient)
with open('example.txt', 'r') as file:
    for line in file:
        print(line.strip())

# Writing Files
with open('example.txt', 'w') as file:
    file.write('Hello World\n')   # Write string
    file.writelines(['Line 1\n', 'Line 2\n'])  # Write multiple lines

# Appending to Files
with open('example.txt', 'a') as file:
    file.write('Appended text\n')

# File Position
with open('example.txt', 'r') as file:
    file.tell()          # Current position
    file.seek(0)         # Move to start
    file.seek(10)        # Move to position 10
    file.seek(0, 2)      # Move to end

# Binary Files
with open('example.bin', 'wb') as file:
    file.write(bytes([1, 2, 3]))

with open('example.bin', 'rb') as file:
    data = file.read()   # Read bytes

# Error Handling
try:
    with open('nonexistent.txt', 'r') as file:
        content = file.read()
except FileNotFoundError:
    print("File not found")
except PermissionError:
    print("Permission denied")

# File Properties
import os

# Check if file exists
os.path.exists('example.txt')     # True/False

# File size
os.path.getsize('example.txt')    # Size in bytes

# File timestamps
os.path.getctime('example.txt')   # Creation time
os.path.getmtime('example.txt')   # Modification time
os.path.getatime('example.txt')   # Access time

# File Operations
os.rename('old.txt', 'new.txt')   # Rename file
os.remove('file.txt')             # Delete file
os.mkdir('directory')             # Create directory
os.rmdir('directory')             # Remove directory

# Working with Paths
import pathlib

# Create path object
path = pathlib.Path('example.txt')

# Path operations
path.exists()            # Check if exists
path.is_file()          # Check if file
path.is_dir()           # Check if directory
path.suffix             # File extension
path.stem               # Filename without extension
path.parent             # Parent directory

# CSV Files
import csv

# Reading CSV
with open('data.csv', 'r') as file:
    reader = csv.reader(file)
    for row in reader:
        print(row)

# Writing CSV
with open('data.csv', 'w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(['Name', 'Age'])
    writer.writerows([['John', 30], ['Jane', 25]])

# JSON Files
import json

# Reading JSON
with open('data.json', 'r') as file:
    data = json.load(file)

# Writing JSON
with open('data.json', 'w') as file:
    json.dump(data, file, indent=4)

# Performance Tips
"""
1. Use 'with' statement for automatic file closing
2. Use iteration for large files
3. Use appropriate buffer size for binary files
4. Use proper encoding for text files
"""

# Common Encodings
"""
'utf-8'     - Unicode (recommended)
'ascii'     - ASCII
'utf-16'    - Unicode 16-bit
'utf-32'    - Unicode 32-bit
"""

# Example with Encoding
with open('file.txt', 'r', encoding='utf-8') as file:
    content = file.read()

# File-like Objects
from io import StringIO, BytesIO

# String as file
str_io = StringIO("Hello World")
content = str_io.read()

# Bytes as file
bytes_io = BytesIO(b"Hello World")
content = bytes_io.read()
```

### Conditional Statements

Python uses conditional statements to control program flow based on conditions.

```python
# Basic if Statement
x = 10
if x > 0:
    print("Positive")    # Executes if x > 0

# if-else Statement
if x > 0:
    print("Positive")
else:
    print("Non-positive")

# if-elif-else Chain
x = 0
if x > 0:
    print("Positive")
elif x < 0:
    print("Negative")
else:
    print("Zero")

# Nested if Statements
if x >= 0:
    if x == 0:
        print("Zero")
    else:
        print("Positive")
else:
    print("Negative")

# Conditional Expressions (Ternary Operator)
age = 20
status = "Adult" if age >= 18 else "Minor"

# Multiple Conditions
# Using and
if x > 0 and x < 10:    # Both conditions must be True
    print("Single digit positive number")

# Using or
if x < 0 or x > 100:    # At least one condition must be True
    print("Out of range")

# Using not
if not x == 0:          # True if x is not 0
    print("Non-zero")

# Chaining Comparisons
if 0 <= x <= 10:        # Same as: if x >= 0 and x <= 10
    print("Between 0 and 10")

# Truth Value Testing
# False values
"""
False
None
0
0.0
'' (empty string)
[] (empty list)
{} (empty dict)
() (empty tuple)
set() (empty set)
"""

# True values (everything else)
if x:                   # True if x is not a False value
    print("Truthy value")

# Identity Comparison
if x is None:           # Check identity (use for None)
    print("x is None")

if x is not None:       # Check not None
    print("x is not None")

# Membership Testing
lst = [1, 2, 3]
if x in lst:            # Check membership
    print("Found in list")

if x not in lst:        # Check non-membership
    print("Not in list")

# Pattern Matching (Python 3.10+)
status = 200
match status:
    case 200:
        print("OK")
    case 404:
        print("Not Found")
    case _:             # Default case
        print("Unknown")

# Complex Pattern Matching
command = ("move", 10, 20)
match command:
    case ("move", x, y):
        print(f"Moving to {x},{y}")
    case ("quit",):
        print("Quitting")
    case _:
        print("Unknown command")

# Best Practices
"""
1. Use 'is' only for None, True, False comparisons
2. Avoid nested if statements when possible
3. Use positive conditions when possible
4. Keep conditions simple and readable
5. Use parentheses for complex conditions
"""

# Common Patterns
# Early return
def process(x):
    if x < 0:
        return None     # Early return for invalid input
    # Process valid input

# Guard clause
def divide(x, y):
    if y == 0:
        raise ValueError("Cannot divide by zero")
    return x / y

# Switch-like dictionary
operations = {
    'add': lambda x, y: x + y,
    'sub': lambda x, y: x - y,
}
result = operations.get('add', lambda x, y: None)(5, 3)

# Exception handling with conditionals
try:
    value = int("123")
except ValueError:
    value = 0          # Default value on error

# Walrus operator (Python 3.8+)
if (n := len([1, 2, 3])) > 2:
    print(f"List is long: {n} elements")
```

### Loops

Python provides several types of loops to iterate over sequences and perform repeated actions.

```python
# Basic for Loop
fruits = ['apple', 'banana', 'cherry']
for fruit in fruits:
    print(fruit)

# Looping with range()
for i in range(5):
    print(i)  # 0 to 4

# Looping with range(start, stop, step)
for i in range(1, 10, 2):
    print(i)  # 1, 3, 5, 7, 9

# Looping over a string
for char in "Python":
    print(char)

# Looping with enumerate()
for index, value in enumerate(fruits):
    print(f"Index {index}: {value}")

# Looping with zip()
names = ['Alice', 'Bob', 'Charlie']
ages = [25, 30, 35]
for name, age in zip(names, ages):
    print(f"{name} is {age} years old")

# While Loop
count = 0
while count < 5:
    print(count)
    count += 1

# Infinite Loop with break
while True:
    print("This will run forever unless stopped")
    break

# Loop Control Statements
# break
for i in range(10):
    if i == 5:
        break  # Exit loop
    print(i)

# continue
for i in range(10):
    if i % 2 == 0:
        continue  # Skip even numbers
    print(i)

# else with Loops
for i in range(5):
    print(i)
else:
    print("Loop completed without break")

# Nested Loops
for i in range(3):
    for j in range(2):
        print(f"i={i}, j={j}")

# List Comprehensions
squares = [x**2 for x in range(10)]
print(squares)

# Dictionary Comprehensions
squared_dict = {x: x**2 for x in range(5)}
print(squared_dict)

# Set Comprehensions
unique_squares = {x**2 for x in range(-3, 4)}
print(unique_squares)

# Generator Expressions
squares_gen = (x**2 for x in range(10))
for square in squares_gen:
    print(square)

# Best Practices
"""
1. Use list comprehensions for simple loops that create lists
2. Use enumerate() for index-value pairs
3. Use zip() for parallel iteration
4. Avoid modifying the sequence you're iterating over
5. Use break and continue judiciously
"""

# Common Patterns
# Accumulating a sum
total = sum(range(1, 101))  # Sum of 1 to 100

# Finding an item
found = False
for item in fruits:
    if item == 'banana':
        found = True
        break

# Filtering items
filtered = [x for x in range(10) if x % 2 == 0]

# Transforming items
transformed = [x * 2 for x in range(5)]
```
