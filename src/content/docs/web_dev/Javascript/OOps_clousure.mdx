---
title: "OOPs and Closure"
sidebar: {
    order: 5
}
---

## OOPs

- OOPs is a programming paradigm based on the concept of "objects", which can contain data and code to manipulate that data.
- Objects can have methods, which are functions associated with the object.
- OOPs is used to structure code into reusable, modular, and maintainable pieces.

### Object literals

- Object literals are a way to create objects in JavaScript.
- They are defined using curly braces `{}`.
- Properties are defined as key-value pairs.
- Methods are defined as functions.

```javascript
const person = {
    name: "John",
    age: 30,
    sayHello: function() {
        console.log(`Hello, my name is ${this.name}`);
    }
};
```

- `this` keyword refers to the current object/context. `this` is not a fixed value but changes depending on the context.
- Remember when we are visualising the `call stack` in execution  context of javascript whenever a new function is called a new execution context is created and `this` is set to the current object/context.

### Classes

- JavaScript is a prototype-based language that supports object-oriented programming with classes.
- Classes are templates for creating objects. They encapsulate data with code to work on that data. Classes in JS are built on prototypes but have a more syntactical sugar.
- `constructor` is a special method for creating and initializing an object created with a class.

```javascript
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    sayHello() {
        console.log(`Hello, my name is ${this.name}`);
    }
}

const person1 = new Person("John", 30);
person1.sayHello();
```

### Constructor Function

- `new` keyword creates a new object and sets the `this` keyword to the new object.
- `this` keyword inside the constructor function refers to the new object being created.
- new keyword calls the constructor function which passes the values to the object.

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.sayHello = function() {
        console.log(`Hello, my name is ${this.name}`);
    }
}

const person1 = new Person("John", 30);
person1.sayHello();
```

## Prototype

- Prototype is an object that is associated with every object in JavaScript.
- It is used to add methods and properties to objects.
- It is used to implement inheritance in JavaScript.

### Prototype inheritance

- In JavaScript, every thing is a object.
- Javascript will look for the property or method in the object itself and if it is not found it will look for it in the prototype object until it reaches the end of the prototype chain.
- Prototype inheritance is a way to inherit properties and methods from a prototype object.

```ascii
                                        ┌─────────┐
                                        │  null   │
                                        └────┬────┘
                                             │
                                             ▼
                                    ┌─────────────────┐
                                    │ Object.prototype│
                                    └────────┬────────┘
                                             │
                     ┌───────────────────────┼───────────────────────┐
                     │                       │                       │
                     ▼                       ▼                       ▼
            ┌─────────────────┐     ┌───────────────┐      ┌───────────────┐
            │ Array.prototype  │     │String.prototype│    │Function.prototype│
            └────────┬────────┘     └───────┬───────┘      └───────┬───────┘
                     │                      │                       │
                     ▼                      ▼                       ▼
              ┌──────────┐           ┌──────────┐            ┌──────────┐
              │  Array   │           │  String  │            │ Function │
              └──────────┘           └──────────┘            └──────────┘
                     │                      │                       │
                     ▼                      ▼                       ▼
              ┌──────────┐           ┌──────────┐            ┌──────────┐
              │ [1,2,3]  │           │ "hello"  │            │function(){}│
              └──────────┘           └──────────┘            └──────────┘
```

#### Creating your own prototype

- We can add our own properties and methods to the prototype object.

```javascript
Person.prototype.sayHello = function() {
    console.log(`Hello, my name is ${this.name}`);
}

const person1 = new Person("John", 30);
person1.sayHello();   //without new keyword this will be undefined.prototype won't be linked.constructer function won't be called.

// creating prototype at the object level.
const String = "Hello";
const arr = [1,2,3];
const func = function() {
    console.log("Hello");
}

Object.prototype.sayHello = function() {
    console.log(`Hello`);
}

String.sayHello();  //Hello
arr.sayHello();    //Hello
func.sayHello();   //Hello

// Linking object to a object.
const obj = {
    name: "John"
}

const obj2 = {
    name1: "Jane"
}
// old way of linking object to a object.
obj2.__proto__ = obj;

// new way of linking object to a object.
Object.setPrototypeOf(obj2, obj);

console.log(obj2.name);  //John
console.log(obj2.name1);   //Jane

// Creating your own prototype method
const for = "ghtdk     ";

String.prototype.trueLength = function() {
    console.log(`True length is ${this.trim().length}`);
}

for.length;  //10
for.trueLength();  //True length is 7
```

### call , apply and bind

- When the setName function is called with the createUser function, the setName function creates its own new execution context and gets deleted after the execution of setName function.
- The call keyword is used to hold the reference of the setName function even after the execution of setName function.
- `this` keyword is used to tell the setName function to pass the `this` value to the createUser function.

```javascript
function setName(name) {
    this.name = name;
}

function createUser(name, email, password) {
    setName(name);
    this.email = email;
    this.password = password;
}

const user = new createUser("John", "john@example.com", "password");
console.log(user); // createUser { email: 'john@example.com', password: 'password' }

// call method
function setName(name) {
    this.name = name;
}

function createUser(name, email, password) {
    setName.call(this, name);
    this.email = email;
    this.password = password;
}

const user1 = new createUser("John", "john@example.com", "password");
console.log(user1); // createUser { name: 'John', email: 'john@example.com', password: 'password' }
```
#### apply method

- `apply` method calls a function with a given `this` value and arguments provided as an array.

```javascript
function setUserInfo(name, age, city) {
    this.name = name;
    this.age = age;
    this.city = city;
}

function createUser(name, age, city, email, password) {
    setUserInfo.apply(this, [name, age, city]);  // passing arguments as array
    this.email = email;
    this.password = password;
}

const user = new createUser("John", 30, "New York", "john@example.com", "password");
console.log(user); 
// createUser {
//   name: 'John',
//   age: 30,
//   city: 'New York',
//   email: 'john@example.com',
//   password: 'password'
// }
```
#### bind method

- `bind` method creates a new function that, when called, has its `this` keyword set to the provided value.
- Unlike `call` and `apply`, `bind` doesn't immediately invoke the function but returns a new function with the bound context.
- This is particularly useful when you want to preserve the context of `this` in callbacks and event handlers.

```javascript
function greet() {
    console.log(`Hello, my name is ${this.name}`);
}

const user = {
    name: "John"
};

const boundGreet = greet.bind(user);
boundGreet(); // Hello, my name is John

// Practical example with event handlers
class Button {
    constructor(text) {
        this.text = text;
        this.clickHandler = this.clickHandler.bind(this);
    }

    clickHandler() {
        console.log(`Button ${this.text} was clicked`);
    }

    render() {
        const button = document.createElement('button');
        button.addEventListener('click', this.clickHandler);
        return button;
    }
}
```
