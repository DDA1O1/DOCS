---
title: "OOPs and Closure"
sidebar: {
    order: 5
}
---

## OOPs

- OOPs is a programming paradigm based on the concept of "objects", which can contain data and code to manipulate that data.
- Objects can have methods, which are functions associated with the object.
- OOPs is used to structure code into reusable, modular, and maintainable pieces.

### Object literals

- Object literals are a way to create objects in JavaScript.
- They are defined using curly braces `{}`.
- Properties are defined as key-value pairs.
- Methods are defined as functions.

```javascript
const person = {
    name: "John",
    age: 30,
    sayHello: function() {
        console.log(`Hello, my name is ${this.name}`);
    }
};
```

- `this` keyword refers to the current object/context. `this` is not a fixed value but changes depending on the context.
- Remember when we are visualising the `call stack` in execution  context of javascript whenever a new function is called a new execution context is created and `this` is set to the current object/context.


## Prototype

- Prototype is an object that is associated with every object in JavaScript.
- It is used to add methods and properties to objects.
- It is used to implement inheritance in JavaScript.

### Prototype inheritance

- In JavaScript, every thing is a object.
- Javascript will look for the property or method in the object itself and if it is not found it will look for it in the prototype object until it reaches the end of the prototype chain.
- Prototype inheritance is a way to inherit properties and methods from a prototype object.

```ascii
                                        ┌─────────┐
                                        │  null   │
                                        └────┬────┘
                                             │
                                             ▼
                                    ┌─────────────────┐
                                    │ Object.prototype│
                                    └────────┬────────┘
                                             │
                     ┌───────────────────────┼───────────────────────┐
                     │                       │                       │
                     ▼                       ▼                       ▼
            ┌─────────────────┐     ┌───────────────┐      ┌───────────────┐
            │ Array.prototype  │     │String.prototype│    │Function.prototype│
            └────────┬────────┘     └───────┬───────┘      └───────┬───────┘
                     │                      │                       │
                     ▼                      ▼                       ▼
              ┌──────────┐           ┌──────────┐            ┌──────────┐
              │  Array   │           │  String  │            │ Function │
              └──────────┘           └──────────┘            └──────────┘
                     │                      │                       │
                     ▼                      ▼                       ▼
              ┌──────────┐           ┌──────────┐            ┌──────────┐
              │ [1,2,3]  │           │ "hello"  │            │function(){}│
              └──────────┘           └──────────┘            └──────────┘
```

#### Creating your own prototype

- We can add our own properties and methods to the prototype object.

```javascript
Person.prototype.sayHello = function() {
    console.log(`Hello, my name is ${this.name}`);
}

const person1 = new Person("John", 30);
person1.sayHello();   //without new keyword this will be undefined.prototype won't be linked.constructer function won't be called.

// creating prototype at the object level.
const String = "Hello";
const arr = [1,2,3];
const func = function() {
    console.log("Hello");
}

Object.prototype.sayHello = function() {
    console.log(`Hello`);
}

String.sayHello();  //Hello
arr.sayHello();    //Hello
func.sayHello();   //Hello

// Linking object to a object.
const obj = {
    name: "John"
}

const obj2 = {
    name1: "Jane"
}
// old way of linking object to a object.
obj2.__proto__ = obj;

// new way of linking object to a object.
Object.setPrototypeOf(obj2, obj);

console.log(obj2.name);  //John
console.log(obj2.name1);   //Jane

// Creating your own prototype method
const for = "ghtdk     ";

String.prototype.trueLength = function() {
    console.log(`True length is ${this.trim().length}`);
}

for.length;  //10
for.trueLength();  //True length is 7
```

### Call and this keyword

#### Call
- When the setName function is called with the createUser function, the setName function creates its own new execution context and gets deleted after it's execution.
- The call keyword is used to hold the reference of the setName function even after the execution of setName function.
- `this` keyword is used in the `call(this, name)` to tell the setName function to pass the `this` context of setName function to the createUser function.

```javascript


function createUser(name, email, password) {
    function setName(name) {
        this.name = name;
    }
    setName(name);
    this.email = email;
    this.password = password;
}

const user = new createUser("John", "john@example.com", "password");
console.log(user); // createUser { email: 'john@example.com', password: 'password' }

// call and this keyword 

function createUser(name, email, password) {
    function setName(name) {
        this.name = name;
    }
    setName.call(this, name);
    this.email = email;
    this.password = password;
}

const user1 = new createUser("John", "john@example.com", "password");
console.log(user1); // createUser { name: 'John', email: 'john@example.com', password: 'password' }
```

### Classes



#### Bind

- The `bind` keword is used to bind the `this` context of a function/object to another function/object.
- Without using `bind(this)` keword the execution context of the constructor function will not be passed to the new function/object we are using.
- To put it simply, we would not be able to access the properties and methods of any library/object created with the new keyword which creates a new instance of that object/library.

```javascript
function tr(){
    this.library = 'React';
    this.server = 'Library';
    this.bro = 'bro';

   // document.getElementById('btn').addEventListener('click', handleClick);
   // output of above:
                       // clicked
                       // undefined
                      
   document.getElementById('btn').addEventListener('click', handleClick.bind(this));

}

const tr1 = new tr();  // creates a new instance of tr
console.log(tr1);  // tr1 { library: 'React', server: 'Library', bro: 'bro' }

function handleClick(){
    console.log('clicked');   //clicked
    console.log(this.bro);    //bro
}

class tr2{
        constructor(){
            this.library = 'React';
            this.server = 'Server';
            document.getElementById('btn2').addEventListener('click',handleClick2.bind(this));
            console.log(this);  // tr2 { library: 'React', server: 'Server' }
        
        }
    }

    function handleClick2(){
        console.log('clicked2');  //clicked2
        console.log(this.server);  //Server
    }
    const tr21 = new tr2();  // creates a new instance of tr2
    console.log(tr21);  // tr2 { library: 'React', server: 'Server' }

// function inside the class constructor

class tr2{
        constructor(){
            this.library = 'React';
            this.server = 'Server';
            document.getElementById('btn2').addEventListener('click',this.handleClick2.bind(this));  // this.handleClick2 is being used here to tell that the handleClick2 function is inside the tr2 object not in global execution context.
            console.log(this);  // tr2 { library: 'React', server: 'Server' }
        
        }
    handleClick2(){
        console.log('clicked2');  //clicked2
        console.log(this.server);  //Server
    }
}

```
