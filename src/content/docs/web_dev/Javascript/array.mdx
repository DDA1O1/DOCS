---
title: Arrays , objects and functions
description: Understanding JavaScript arrays and their copy behaviors
sidebar: {
    order: 2
}
---

## Arrays in JavaScript

Arrays in JavaScript are like ordered lists that:
- Start counting from 0 (e.g., first item is at position 0)
- Can grow or shrink in size
- Can store any type of data (numbers, strings, objects, even other arrays)
- Can be modified after creation

```javascript
// Basic array creation and usage
const numbers = [1, 2, 3, 4, 5];
const mixed = ['text', 42, true, { key: 'value' }, [1, 2]];
```

## Array Copy Behaviors

### 1. Reference Copy
The simplest form of copying - creates a new reference to the same array.
```javascript
const original = [1, 2, {x: 3}];
const reference = original;  // Same array in memory

reference.push(4);
console.log(original);  // [1, 2, {x: 3}, 4]  (affected)
console.log(reference); // [1, 2, {x: 3}, 4]  (affected)
```

### 2. Shallow Copy
Creates a new array but maintains references to nested objects.

```ascii
         Shallow Copy Visualization
    ═══════════════════════════════════

Original Array         Copied Array
┌──────────────┐      ┌──────────────┐
│    arr1      │      │    arr2      │
├──────────────┤      ├──────────────┤
│ [0]: 1       │      │ [0]: 1       │
│ [1]: 2       │      │ [1]: 2       │
│ [2]: ─────┐  │      │ [2]: ─────┐  │
└───────────┼──┘      └───────────┼──┘
            │                     │
            │   Heap Memory       │
            │  ┌────────────┐     │
            └─→│ {x: 10}    │←────┘
               └────────────┘
```

```javascript
// Shallow copy methods
const original = [1, 2, {x: 3}];
const shallowCopy1 = [...original];     // Spread operator
const shallowCopy2 = Array.from(original); // Array.from()
const shallowCopy3 = original.slice();     // slice()

// Demonstrating shared references
shallowCopy1[2].x = 100;
console.log(original[2].x);     // 100 (nested object affected)
```

:::tip[Spread Operator]

```javascript
const arr = [1, 2, 3];
const arr2 = [4, 5];
const arr3 = [6, 7];
const newArr = [...arr, ...arr2, ...arr3]; // Returns [1, 2, 3, 4, 5, 6, 7]
```
:::

### 3. Deep Copy
Creates a completely independent copy with new references for all nested items.

```ascii
         Deep Copy Visualization
    ═══════════════════════════════════

Original Array         Deep Copied Array
┌──────────────┐      ┌──────────────┐
│    arr1      │      │    arr2      │
├──────────────┤      ├──────────────┤
│ [0]: 1       │      │ [0]: 1       │
│ [1]: 2       │      │ [1]: 2       │
│ [2]: ─────┐  │      │ [2]: ─────┐  │
└───────────┼──┘      └───────────┼──┘
            │                     │
            │   Heap Memory       │
            │  ┌────────────┐     │  ┌────────────┐
            └─→│ {x: 10}    │     └─→│ {x: 10}    │
               └────────────┘        └────────────┘
               (Object #1)           (Object #2)
```

```javascript
// Modern deep copy methods
const original = [1, 2, {x: 3}];

// Method 1: structuredClone (recommended)
const deepCopy1 = structuredClone(original);

// Method 2: JSON parse/stringify (with limitations)
const deepCopy2 = JSON.parse(JSON.stringify(original));

// Demonstrating independence
deepCopy1[2].x = 200;
console.log(original[2].x);  // Still 3 (unaffected)
```
#### Example

```javascript
const users = [
    { id: 1, name: 'Alice', settings: { theme: 'dark' } },
    { id: 2, name: 'Bob', settings: { theme: 'light' } }
];

// Shallow copy behavior
const shallowUsers = [...users];
shallowUsers[0].settings.theme = 'light';
console.log(users[0].settings.theme);      // 'light' (affected)

// Deep copy behavior
const deepUsers = structuredClone(users);
deepUsers[0].settings.theme = 'dark';
console.log(users[0].settings.theme);      // 'light' (unaffected)
```

## Array Methods

Common array methods can be categorized by whether they modify the original array:

### Non-mutating Methods (Return new array)
```javascript
const arr = [1, 2, 3, 4, 5];
arr.map(item => item * 2);     // Returns [2, 4, 6, 8, 10], arr unchanged
arr.filter(item => item % 2 === 0); // Returns [2, 4], arr unchanged
arr.reduce((acc, item) => acc + item, 0); // Returns 15, arr unchanged
arr.slice(1, 4);              // Returns [2, 3, 4], arr unchanged
arr.forEach(item => console.log(item)); // Returns undefined, arr unchanged
arr.join('-');                      // Returns '1-2-3-4-5', arr unchanged
```

### Mutating Methods (Modify original array)
```javascript
const arr = [1, 2, 3, 4, 5];
arr.splice(1, 2);             // Returns [2, 3], arr is now [1, 4, 5]
arr.push(6);                  // Returns new length 4, arr is now [1, 4, 5, 6]
arr.pop();                    // Returns 6, arr is now [1, 4, 5]
arr.forEach(item => {         // Returns undefined, can mutate arr if callback modifies it
    console.log(item);
});
arr.sort((a, b) => a - b);    // Returns sorted array, arr is now [1, 4, 5, 6].
// Note: sort() method modifies the original array.
```

## Objects

- Objects are collections of key-value pairs
- Keys are strings (or symbols), values can be any type of data
- Objects are mutable
- Objects are unordered

```javascript
const user = {
    name: 'Alice',
    age: 25,
    isAdmin: true,
    "color": red
};

console.log(user.name); // Alice
console.log(user['age']); // 25
console.log(user["color"]); // red
```
#### Object Methods

```javascript
const obj1 = {
    name: "Alice",
    age: 25
};

const obj2 = {
    name1: "Bob",
    age1: 30
};

const obj3 = {...obj1, ...obj2}; // Spread operator

console.log(obj3.name); // Alice
console.log(obj3.age1); // 30
console.log(obj3); // { name: 'Alice', age: 25, name1: 'Bob', age1: 30 }
```
- To learn more about the object methods, visit [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object).

## Destructuring

Destructuring allows you to unpack values from arrays or properties from objects into distinct variables. This syntax makes it easier to work with complex data structures.

#### Object Destructuring
```javascript
// Basic destructuring
const person = { name: 'Alice', age: 25, city: 'London' };
const { name, age } = person;
console.log(name);  // 'Alice'
console.log(age);   // 25

// Destructuring with different variable names
const { name: firstName, age: yearsOld } = person;
console.log(firstName);  // 'Alice'
console.log(yearsOld);   // 25

// Default values
const { country = 'Unknown' } = person;
console.log(country);  // 'Unknown' (since it wasn't in person object)
```

#### Array Destructuring
```javascript
// Basic array destructuring
const colors = ['red', 'green', 'blue'];
const [first, second] = colors;
console.log(first);   // 'red'
console.log(second);  // 'green'

// Skip elements using commas
const [,, third] = colors;
console.log(third);   // 'blue'

// Rest pattern
const [primary, ...rest] = colors;
console.log(primary); // 'red'
console.log(rest);    // ['green', 'blue']
```

#### Nested Destructuring
```javascript
const data = {
    user: {
        id: 1,
        details: {
            firstName: 'Alice',
            lastName: 'Smith'
        }
    },
    scores: [10, 20, 30]
};

// Destructuring nested objects and arrays
const { 
    user: { 
        details: { firstName, lastName },
        id
    },
    scores: [firstScore, ...otherScores]
} = data;

console.log(firstName);    // 'Alice'
console.log(id);          // 1
console.log(firstScore);  // 10
console.log(otherScores); // [20, 30]
```

#### JSON
```javascript
// JSON is a string representation of a JavaScript object.

{
    "name": "Alice",
    "age": 25,
    "data1":{
        "name1": "Bob",
        "age1": 30,
        "data2":{
            "name2": "Charlie",
            "age2": 35,
            "data3":{
                "name3": "David",
                "age3": 40
            }
        }
    }
}

// JSON.parse() is used to parse a JSON string and convert it into a JavaScript object.
// JSON.stringify() is used to convert a JavaScript object into a JSON string.
```
## Functions

- Functions are blocks of code that perform a specific task.
- Functions can take input parameters and return output values.
- Functions can be used to organize code and make it more modular and reusable.


