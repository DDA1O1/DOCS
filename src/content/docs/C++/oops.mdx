---
title: "OOPs in C++"
description: "OOPs in C++"
---

- OOPs stands for Object Oriented Programming.It is a programming paradigm based on the concept of `objects`, everything is object in OOPs.
- OOPs is not a language, it is a concept.Almost all languages support OOPs approach.
- `main()` function exist without any class in C++.That means it supports variety of programming styles.
- Bjarne Stroustrup introduced OOPs in C++ in 1985 [OOPSLA](https://stroustrup.com/oopsla.pdf)

### Class and Object
- Class is a blueprint of an object.
- Object is an instance of a class.
- Every new object instance is a copy of original class.

> `<vector>` is a class and `vector<int> v` is an object/instance of that class.
- same as array, but more flexible.
- `vector` allows fast random access to any element.
- It is preferred when random-access performance is the primary need.
- [vector](https://learn.microsoft.com/en-us/cpp/standard-library/vector-class?view=msvc-170) is a class in C++ STL

```cpp
// user defined class
#include <iostream>
#include <vector>

using namespace std;

class Bread {
    public:
        // data members(attributes) fancy name for variables in a class
        string name;
        int quantity;
        vector<string> ingredients; //list of ingredients

        // member functions(methods) fancy name for functions in a class
        void display() {
            cout << "Bread name: " << name << endl;
            cout << "Quantity: " << quantity << endl;
            cout << "Ingredients: ";
            for (string ingredient : ingredients) {
                cout << ingredient << " ";
            }
            cout << endl;
        }
}; // do not forget semicolon

// access modifier
// public: accessible from anywhere
// private: accessible only within the class
// protected: accessible within the class and derived classes

// The default access modifier for a class is private if not specified.

int main() {
    Bread bread; // class name always starts with capital letter and object name always starts with small letter

    bread.name = "Whole Wheat Bread";
    bread.quantity = 10;
    bread.ingredients = {"Flour", "Water", "Yeast", "Salt"};

    bread.display();

    Bread bread2;
    bread2.name = "White Bread";
    bread2.quantity = 5;
    bread2.ingredients = {"Flour", "Water", "Yeast", "Salt"};
    bread2.display();
    return 0;
}
```

### Constructor
- Constructor is a special member function of a class that is automatically called when an object is created.
- It is used to initialize the object.
- It has the same name as the class and no return type.
- It can take parameters.
- It can be parameterized or non-parameterized.
- If no constructor is defined, compiler will automatically generate a default constructor.
```cpp
// default constructor
class Bread {
    public:
        Bread() {
            cout << "Bread constructor called" << endl;
        }
};

int main() {
    Bread bread; //output: Bread constructor called
    return 0;
}

// default values can be assigned in constructor

class Bread {
    public:
        Bread() {
            name = "Unknown";
            quantity = 1;
            ingredients = {"Water"};
        }
        void display() {
            cout << "Bread name: " << name << endl;
            cout << "Quantity: " << quantity << endl;
            cout << "Ingredients: ";
            for (string ingredient : ingredients) {
                cout << ingredient << " ";
            }
            cout << endl;
        }
};

int main() {
    Bread bread;  //output: Bread constructor called
    bread.display(); //output: Bread name: Unknown, Quantity: 1, Ingredients: Water
    return 0;
}

// parameterized constructor

class Bread {
    public:
        Bread(string name, int quantity, vector<string> ingredients) {
            this->name = name;
            this->quantity = quantity;
            this->ingredients = ingredients;
        }
        void display() {
            cout << "Bread name: " << name << endl;
            cout << "Quantity: " << quantity << endl;
            cout << "Ingredients: ";
            for (string ingredient : ingredients) {
                cout << ingredient << " ";
            }
            cout << endl;
        }
};

int main() {
    Bread bread("Whole Wheat Bread", 10, {"Flour", "Water", "Yeast", "Salt"});
    bread.display();
    return 0;
}
```
##### Copy Constructor and Destructor

- Copy constructor is a constructor that creates an object by copying another object.
- It is used to initialize an object with the values of another object.
- It takes the same type of object as a parameter.

```cpp
// normal copy
class Bread {
    public:
        string name;
        int quantity;
        vector<string> ingredients;

        Bread(string name, int quantity, vector<string> ingredients) {
            this->name = name;
            this->quantity = quantity;
            this->ingredients = ingredients;
        }
        void display() {
            cout << "Bread name: " << name << endl;
            cout << "Quantity: " << quantity << endl;
            cout << "Ingredients: ";
            for (string ingredient : ingredients) {
                cout << ingredient << " ";
            }
            cout << endl;
        }
};

int main() {
    Bread bread1("Whole Wheat Bread", 10, {"Flour", "Water", "Yeast", "Salt"});
    Bread bread2 = bread1;
    bread1.name = "White Bread";
    bread1.display(); //output: Bread name: White Bread, Quantity: 10, Ingredients: Flour Water Yeast Salt
    bread2.display(); //output: Bread name: Whole Wheat Bread, Quantity: 10, Ingredients: Flour Water Yeast Salt
    return 0;
}
```
- The normal copy works absolutely fine.

The problem arises when you want to deal with dynamic memory allocation with pointers.In `Stack memory` the allocation and deallocation is handled automatically.But in `Heap memory` the allocation and deallocation/deletion have to be done manually.Destructor is used to deallocate the memory `~` is used to define destructor also called as `tilde operator`.

```cpp
class Bread {
    public:
        string *name;
        Bread(string name) {
            this->name = new string(name);  // dynamic memory allocation with new keyword
        }
        // destructor
        ~Bread() {  
            delete name;  // dynamic memory deallocation with delete keyword
            cout << "Bread destructor called" << endl;
        }
        void display() {
            cout << "Bread name: " << *name << endl;
        }
};

int main() {
    Bread bread("Whole Wheat Bread");
    Bread bread2 = bread;

    *bread.name = "White Bread";
    bread.display(); //output: Bread name: White Bread 
    bread2.display(); //output: Bread name: White Bread
    return 0;
}
// output: Bread destructor called
// output: Bread destructor called
```
- When you don't define a copy constructor, C++ automatically creates one.This is known as `shallow copy`.That means both objects will point to the same memory location.Changes made in one object will be reflected in another object.

:::danger[Memory Error]
After the execution of program, destructor will be called for both objects and deallocate the same memory.The memory will be deallocated twice which is a memory error.
:::

- To avoid this problem, we need to define our own copy constructor.This is known as `deep copy`.

```cpp
class Bread {
    public:
        string *name;
        Bread(string name) {
            this->name = new string(name);
        }
        // copy constructor
        // const is used to prevent the object from being modified
        // &other is the deep copy of the object
        Bread(const Bread &other) {  
            this->name = new string(*other.name); //`*` is used cause `name` is a string pointer
        }
        // destructor
        ~Bread() {
            delete name;
            cout << "Bread destructor called" << endl;
        }
        void display() {
            cout << "Bread name: " << *name << endl;
        }
};

int main() {
    Bread bread("Whole Wheat Bread");
    Bread bread2 = bread;
    *bread.name = "White Bread";
    bread.display(); //output: Bread name: White Bread
    bread2.display(); //output: Bread name: Whole Wheat Bread
    return 0;
}
```

#### Delegation constructor
- Delegation constructor is a constructor that calls another constructor from the same class.

Suppose you have a class `Bread` and you want to initialize the object with default values and also with some specific values.You can use delegation constructor to avoid code duplication.

Means you just want a normal bread.The default constructor will only work if you does not pass any value but here you are telling just give me a normal bread. You are here passing one value the name `normal bread`.

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Bread {
    public:
        string name;
        int quantity;
        vector<string> ingredients;

        // Delegation constructor
        Bread(string name) : Bread(name, 1, {"Flour", "Water", "Yeast", "Salt"}) {}

        // Main constructor
        Bread(string name, int quantity, vector<string> ingredients) {
            this->name = name;
            this->quantity = quantity;
            this->ingredients = ingredients;
        }
        void display() {
            cout << "Bread name: " << name << endl;
            cout << "Bread quantity: " << quantity << endl;
            cout << "Bread ingredients: ";
            for (string ingredient : ingredients) {
                cout << ingredient << " ";
            }
        }
};

int main() {
    Bread normalBread("Normal Bread");
    normalBread.display();
    return 0;
}
```

### Getter and Setter

- Getters and setters provide controlled access to class properties

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Bread {
    private:
        string name;
        int quantity;
        vector<string> ingredients;
    
    public:
        Bread(){
            name = "Unknown";
            quantity = 1;
            ingredients = {"Flour", "Water", "Yeast", "Salt"};
        }

        Bread(string name, int quantity, vector<string> ingredients) {
            this->name = name;
            this->quantity = quantity;
            this->ingredients = ingredients;
        }

        // getter
        string getName() {
            return name + " Bread";
        }

        // setter
        void setName(string name) {
            this->name = name;
        }

        // getter for quantity
        int getQuantity() {
            return quantity + 1;
        }

        // setter for quantity
        void setQuantity(int quantity) {
            if (quantity > 0) {  // Validate before setting
                this->quantity = quantity;
            }
        }

        // getter for ingredients
        vector<string> getIngredients() {
            return ingredients;
        }

        // setter for ingredients
        void setIngredients(vector<string> ingredients) {
            this->ingredients = ingredients;
        }

        void display() {
            cout << "Bread name: " << name << endl;
            cout << "Bread quantity: " << quantity << endl;
            cout << "Bread ingredients: ";
            for (string ingredient : ingredients) {
                cout << ingredient << " ";
            }
        }
};

int main() {
    Bread bread;  // Creates bread with default values
    
    // Using setter to change values
    bread.setName("Sourdough");                    // Modifies private 'name' safely
    bread.setQuantity(5);                          // Modifies private 'quantity' safely
    bread.setIngredients({"Flour", "Starter"});    // Modifies private 'ingredients' safely
    
    // Using getter to access values
    cout << "Name: " << bread.getName() << endl;        // Reads private 'name' safely
    cout << "Quantity: " << bread.getQuantity() << endl;// Reads private 'quantity' safely
    cout << "Ingredients: ";
    for (string ingredient : bread.getIngredients()) {
        cout << ingredient << " ";
    }
    cout << endl;
    cout <<"---------------------"<< endl;

    bread.display();
    return 0;
}
```

### Friend Keyword
- Friend keyword is used to declare a friend function/friend class.
- Friend function is a function that is not a member of a class but has access to the private members of a class.
- It is declared in the class with the `friend` keyword.
- It is defined outside the class.
- It can access the private members of the class.

```cpp
#include <iostream>
using namespace std;

class Bread {
    private:
        string name;
        int quantity;
        
        // friend keyword is used to declare a friend function
        // & is used to pass the object by reference
        friend bool compareQuantity(const Bread &lhs, const Bread &rhs);

    // Another way to declare constructor
    public:
        Bread(string name, int quantity): name(name), quantity(quantity) {}

        void display() const { // const keyword is used to prevent the function from modifying the object
            cout << "Bread name: " << name << endl;
            cout << "Bread quantity: " << quantity << endl;
        }
};

// friend function is defined outside the class
bool compareQuantity(const Bread &lhs, const Bread &rhs) {
    return lhs.quantity > rhs.quantity;
}

int main() {
    Bread bread("Sourdough", 5);
    Bread bread2("White Bread", 10);
    bread.display();
    bread2.display();

    if (compareQuantity(bread, bread2)) {
        cout << "bread quantity is greater than bread2 quantity" << endl;
    } else {
        cout << "bread2 quantity is greater than bread quantity" << endl;
    }
    return 0;
}

```
- The same program can be written using `getter` and `setter` instead of `friend` keyword.

```cpp
#include <iostream>
using namespace std;

class Bread {
    private:
        string name;
        int quantity;

    public:
        Bread(string name, int quantity): name(name), quantity(quantity) {}
        
        int getQuantity() const { return quantity; }

        void display() const {
            cout << "Bread name: " << name << endl;
            cout << "Bread quantity: " << quantity << endl;
        }
};

// Regular function using public interface
bool compareQuantity(const Bread &lhs, const Bread &rhs) {
    return lhs.getQuantity() > rhs.getQuantity();
}

int main() {
    Bread bread("Sourdough", 5);
    Bread bread2("White Bread", 10);
    bread.display();
    bread2.display();

    if (compareQuantity(bread, bread2)) {
        cout << "bread quantity is greater than bread2 quantity" << endl;
    } else {
        cout << "bread2 quantity is greater than bread quantity" << endl;
    }
    return 0;
}
```
- Suppose you have a Bakery System and you want to check the secret recipe of the bread.You do not want to expose the secret recipe to the outside world.But you want to let your staff check the secret recipe of the bread.If you use `getter` and `setter` then anyone can access the secret recipe.

```cpp
#include <iostream>
#include <string>
using namespace std;

class Bread {
private:
    string name;
    double secretRecipe;
    double price;

public:
    Bread(string n, double recipe, double p): 
        name(n), secretRecipe(recipe), price(p) {}

    // Added getters
    string getName() const { return name; }
    double getRecipe() const { return secretRecipe; }
    double getPrice() const { return price; }

    void display() {
        cout << "Bread: " << name << ", Price: $" << price << endl;
    }
};

class BakerySystem {
public:
    void checkRecipe(const Bread& bread) {
        cout << "Checking secret recipe: " << bread.getRecipe() << endl;
    }

    double getBulkPrice(const Bread& bread, int quantity) {
        return bread.getPrice() * quantity * 0.9;
    }
};

int main() {
    Bread sourdough("Sourdough", 0.75, 5.99);
    BakerySystem bakery;

    sourdough.display();
    bakery.checkRecipe(sourdough);
    cout << "Bulk price: $" << bakery.getBulkPrice(sourdough, 10) << endl;

    cout << "I stole the recipe: " << sourdough.getRecipe() << endl;
    cout << "Internal price: " << sourdough.getPrice() << endl;

    return 0;
}
```
- The same program can be written using `friend` keyword instead of `getter` and `setter` where your staff can only access the secret recipe.

```cpp
#include <iostream>
#include <string>
using namespace std;

class Bread {
private:
    string name;
    double secretRecipe;
    double price;

public:
    Bread(string n, double recipe, double p): 
        name(n), secretRecipe(recipe), price(p) {}

    void display() {
        cout << "Bread: " << name << ", Price: $" << price << endl;
    }

    friend class BakerySystem;
};

class BakerySystem {
public:
    void checkRecipe(const Bread& bread) {
        cout << "Checking secret recipe: " << bread.secretRecipe << endl;
    }

    double getBulkPrice(const Bread& bread, int quantity) {
        return bread.price * quantity * 0.9;
    }
};

int main() {
    Bread sourdough("Sourdough", 0.75, 5.99);
    BakerySystem bakery;

    sourdough.display();
    bakery.checkRecipe(sourdough);
    cout << "Bulk price: $" << bakery.getBulkPrice(sourdough, 10) << endl;

    return 0;
}
```