---
title: "OOPs in C++"
description: "OOPs in C++"
---

- OOPs stands for Object Oriented Programming.It is a programming paradigm based on the concept of `objects`, everything is object in OOPs.
- OOPs is not a language, it is a concept.Almost all languages support OOPs approach.
- `main()` function exist without any class in C++.That means it supports variety of programming styles.
- Bjarne Stroustrup introduced OOPs in C++ in 1985 [OOPSLA](https://stroustrup.com/oopsla.pdf)

### Class and Object
- Class is a blueprint of an object.
- Object is an instance of a class.
- Every new object instance is a copy of original class.

> `<vector>` is a class and `vector<int> v` is an object/instance of that class.
- same as array, but more flexible.
- `vector` allows fast random access to any element.
- It is preferred when random-access performance is the primary need.
- [vector](https://learn.microsoft.com/en-us/cpp/standard-library/vector-class?view=msvc-170) is a class in C++ STL

```cpp
// user defined class
#include <iostream>
#include <vector>

using namespace std;

class Bread {
    public:
        // data members(attributes) fancy name for variables in a class
        string name;
        int quantity;
        vector<string> ingredients; //list of ingredients

        // member functions(methods) fancy name for functions in a class
        void display() {
            cout << "Bread name: " << name << endl;
            cout << "Quantity: " << quantity << endl;
            cout << "Ingredients: ";
            for (string ingredient : ingredients) {
                cout << ingredient << " ";
            }
            cout << endl;
        }
}; // do not forget semicolon

// access modifier
// public: accessible from anywhere
// private: accessible only within the class
// protected: accessible within the class and derived classes

// The default access modifier for a class is private if not specified.

int main() {
    Bread bread; // class name always starts with capital letter and object name always starts with small letter

    bread.name = "Whole Wheat Bread";
    bread.quantity = 10;
    bread.ingredients = {"Flour", "Water", "Yeast", "Salt"};

    bread.display();

    Bread bread2;
    bread2.name = "White Bread";
    bread2.quantity = 5;
    bread2.ingredients = {"Flour", "Water", "Yeast", "Salt"};
    bread2.display();
    return 0;
}
```

### Constructor
- Constructor is a special member function of a class that is automatically called when an object is created.
- It is used to initialize the object.
- It has the same name as the class and no return type.
- It can take parameters.
- It can be parameterized or non-parameterized.
- If no constructor is defined, compiler will automatically generate a default constructor.
```cpp
// default constructor
class Bread {
    public:
        Bread() {
            cout << "Bread constructor called" << endl;
        }
};

int main() {
    Bread bread; //output: Bread constructor called
    return 0;
}

// default values can be assigned in constructor

class Bread {
    public:
        Bread() {
            name = "Unknown";
            quantity = 1;
            ingredients = {"Water"};
        }
        void display() {
            cout << "Bread name: " << name << endl;
            cout << "Quantity: " << quantity << endl;
            cout << "Ingredients: ";
            for (string ingredient : ingredients) {
                cout << ingredient << " ";
            }
            cout << endl;
        }
};

int main() {
    Bread bread;  //output: Bread constructor called
    bread.display(); //output: Bread name: Unknown, Quantity: 1, Ingredients: Water
    return 0;
}

// parameterized constructor

class Bread {
    public:
        Bread(string name, int quantity, vector<string> ingredients) {
            this->name = name;
            this->quantity = quantity;
            this->ingredients = ingredients;
        }
        void display() {
            cout << "Bread name: " << name << endl;
            cout << "Quantity: " << quantity << endl;
            cout << "Ingredients: ";
            for (string ingredient : ingredients) {
                cout << ingredient << " ";
            }
            cout << endl;
        }
};

int main() {
    Bread bread("Whole Wheat Bread", 10, {"Flour", "Water", "Yeast", "Salt"});
    bread.display();
    return 0;
}
```
##### Copy Constructor and Destructor

- Copy constructor is a constructor that creates an object by copying another object.
- It is used to initialize an object with the values of another object.
- It takes the same type of object as a parameter.

```cpp
// normal copy
class Bread {
    public:
        string name;
        int quantity;
        vector<string> ingredients;

        Bread(string name, int quantity, vector<string> ingredients) {
            this->name = name;
            this->quantity = quantity;
            this->ingredients = ingredients;
        }
        void display() {
            cout << "Bread name: " << name << endl;
            cout << "Quantity: " << quantity << endl;
            cout << "Ingredients: ";
            for (string ingredient : ingredients) {
                cout << ingredient << " ";
            }
            cout << endl;
        }
};

int main() {
    Bread bread1("Whole Wheat Bread", 10, {"Flour", "Water", "Yeast", "Salt"});
    Bread bread2 = bread1;
    bread1.name = "White Bread";
    bread1.display(); //output: Bread name: White Bread, Quantity: 10, Ingredients: Flour Water Yeast Salt
    bread2.display(); //output: Bread name: Whole Wheat Bread, Quantity: 10, Ingredients: Flour Water Yeast Salt
    return 0;
}
```
- The normal copy works absolutely fine.

The problem arises when you want to deal with dynamic memory allocation with pointers.In `Stack memory` the allocation and deallocation is handled automatically.But in `Heap memory` the allocation and deallocation/deletion have to be done manually.Destructor is used to deallocate the memory `~` is used to define destructor also called as `tilde operator`.

```cpp
class Bread {
    public:
        string *name;
        Bread(string name) {
            this->name = new string(name);  // dynamic memory allocation with new keyword
        }
        // destructor
        ~Bread() {  
            delete name;  // dynamic memory deallocation with delete keyword
            cout << "Bread destructor called" << endl;
        }
        void display() {
            cout << "Bread name: " << *name << endl;
        }
};

int main() {
    Bread bread("Whole Wheat Bread");
    Bread bread2 = bread;

    *bread.name = "White Bread";
    bread.display(); //output: Bread name: White Bread 
    bread2.display(); //output: Bread name: White Bread
    return 0;
}
// output: Bread destructor called
// output: Bread destructor called
```
- When you don't define a copy constructor, C++ automatically creates one.This is known as `shallow copy`.That means both objects will point to the same memory location.Changes made in one object will be reflected in another object.

:::danger[Memory Error]
After the execution of program, destructor will be called for both objects and deallocate the same memory.The memory will be deallocated twice which is a memory error.
:::

- To avoid this problem, we need to define our own copy constructor.This is known as `deep copy`.

```cpp
class Bread {
    public:
        string *name;
        Bread(string name) {
            this->name = new string(name);
        }
        // copy constructor
        // const is used to prevent the object from being modified
        // &other is the deep copy of the object
        Bread(const Bread &other) {  
            this->name = new string(*other.name); //`*` is used cause `name` is a string pointer
        }
        // destructor
        ~Bread() {
            delete name;
            cout << "Bread destructor called" << endl;
        }
        void display() {
            cout << "Bread name: " << *name << endl;
        }
};

int main() {
    Bread bread("Whole Wheat Bread");
    Bread bread2 = bread;
    *bread.name = "White Bread";
    bread.display(); //output: Bread name: White Bread
    bread2.display(); //output: Bread name: Whole Wheat Bread
    return 0;
}
```

#### Delegation constructor
- Delegation constructor is a constructor that calls another constructor from the same class.

Suppose you have a class `Bread` and you want to initialize the object with default values and also with some specific values.You can use delegation constructor to avoid code duplication.

Means you just want a normal bread.The default constructor will only work if you does not pass any value but here you are telling just give me a normal bread. You are here passing one value the name `normal bread`.

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Bread {
    public:
        string name;
        int quantity;
        vector<string> ingredients;

        // Delegation constructor
        Bread(string name) : Bread(name, 1, {"Flour", "Water", "Yeast", "Salt"}) {}

        // Main constructor
        Bread(string name, int quantity, vector<string> ingredients) {
            this->name = name;
            this->quantity = quantity;
            this->ingredients = ingredients;
        }
        void display() {
            cout << "Bread name: " << name << endl;
            cout << "Bread quantity: " << quantity << endl;
            cout << "Bread ingredients: ";
            for (string ingredient : ingredients) {
                cout << ingredient << " ";
            }
        }
};

int main() {
    Bread normalBread("Normal Bread");
    normalBread.display();
    return 0;
}
```

### Getter and Setter

- Getters and setters provide controlled access to class properties

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Bread {
    private:
        string name;
        int quantity;
        vector<string> ingredients;
    
    public:
        Bread(){
            name = "Unknown";
            quantity = 1;
            ingredients = {"Flour", "Water", "Yeast", "Salt"};
        }

        Bread(string name, int quantity, vector<string> ingredients) {
            this->name = name;
            this->quantity = quantity;
            this->ingredients = ingredients;
        }

        // getter
        string getName() {
            return name + " Bread";
        }

        // setter
        void setName(string name) {
            this->name = name;
        }

        // getter for quantity
        int getQuantity() {
            return quantity + 1;
        }

        // setter for quantity
        void setQuantity(int quantity) {
            if (quantity > 0) {  // Validate before setting
                this->quantity = quantity;
            }
        }

        // getter for ingredients
        vector<string> getIngredients() {
            return ingredients;
        }

        // setter for ingredients
        void setIngredients(vector<string> ingredients) {
            this->ingredients = ingredients;
        }

        void display() {
            cout << "Bread name: " << name << endl;
            cout << "Bread quantity: " << quantity << endl;
            cout << "Bread ingredients: ";
            for (string ingredient : ingredients) {
                cout << ingredient << " ";
            }
        }
};

int main() {
    Bread bread;  // Creates bread with default values
    
    // Using setter to change values
    bread.setName("Sourdough");                    // Modifies private 'name' safely
    bread.setQuantity(5);                          // Modifies private 'quantity' safely
    bread.setIngredients({"Flour", "Starter"});    // Modifies private 'ingredients' safely
    
    // Using getter to access values
    cout << "Name: " << bread.getName() << endl;        // Reads private 'name' safely
    cout << "Quantity: " << bread.getQuantity() << endl;// Reads private 'quantity' safely
    cout << "Ingredients: ";
    for (string ingredient : bread.getIngredients()) {
        cout << ingredient << " ";
    }
    cout << endl;
    cout <<"---------------------"<< endl;

    bread.display();
    return 0;
}
```
